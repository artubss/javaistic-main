---
title: "Introdução ao Spring Framework"
description: "Aprenda sobre o Spring Framework - o framework mais popular para desenvolvimento Java enterprise com exemplos práticos e exercícios"
---

## Introdução ao Spring Framework

O **Spring Framework** é um dos frameworks mais populares para desenvolvimento de aplicações Java enterprise. Criado por Rod Johnson em 2003, o Spring simplifica o desenvolvimento de aplicações Java através de sua arquitetura modular e recursos poderosos.

### Por que usar Spring?

1. **Inversão de Controle (IoC)**: O Spring gerencia a criação e ciclo de vida dos objetos
2. **Injeção de Dependência (DI)**: Facilita o acoplamento frouxo entre componentes
3. **Aspect-Oriented Programming (AOP)**: Permite separar preocupações transversais
4. **Modularidade**: Você pode usar apenas os módulos que precisa
5. **Produtividade**: Reduz código boilerplate e acelera o desenvolvimento
6. **Testabilidade**: Facilita a criação de testes unitários e de integração
7. **Ecosistema Rico**: Integração com outras tecnologias Java

### Arquitetura do Spring

```
Spring Framework
├── Core Container
│   ├── Spring Core (IoC Container)
│   ├── Spring Beans (Bean Factory)
│   ├── Spring Context (Application Context)
│   └── Spring Expression Language (SpEL)
├── Data Access/Integration
│   ├── Spring JDBC
│   ├── Spring ORM (Hibernate, JPA)
│   ├── Spring JMS
│   └── Spring Transaction
├── Web Layer
│   ├── Spring MVC
│   ├── Spring WebFlux
│   └── Spring WebSocket
├── AOP (Aspect-Oriented Programming)
├── Instrumentation
└── Test
```

### Módulos Principais

#### 1. Spring Core Container

**Spring Core**: Funcionalidades fundamentais do framework

- IoC Container
- Gerenciamento de beans
- Configuração de aplicação

**Spring Beans**: Implementação do padrão Factory

- Definição de beans
- Ciclo de vida dos beans
- Escopo dos beans

**Spring Context**: Construído sobre Core e Beans

- ApplicationContext
- Internacionalização
- Eventos e listeners

#### 2. Spring Web

**Spring MVC**: Framework web tradicional

- Controllers
- Views
- Model binding

**Spring WebFlux**: Framework web reativo

- Programação reativa
- Non-blocking I/O
- Backpressure

**Spring WebSocket**: Suporte a WebSockets

- Comunicação bidirecional
- Real-time updates

#### 3. Spring Data Access

**Spring JDBC**: Abstração sobre JDBC

- JdbcTemplate
- NamedParameterJdbcTemplate
- Batch operations

**Spring ORM**: Integração com frameworks ORM

- Hibernate
- JPA
- MyBatis

**Spring Transaction**: Gerenciamento de transações

- Declarative transactions
- Programmatic transactions
- Transaction propagation

### Inversão de Controle (IoC)

O IoC é o princípio fundamental do Spring. Em vez de objetos criarem suas dependências, o Spring cria e injeta as dependências.

#### Conceito Tradicional vs IoC

**Sem IoC (Tradicional)**:

```java
public class ServicoEmail {
    private RepositorioUsuario repositorio;

    public ServicoEmail() {
        this.repositorio = new RepositorioUsuarioImpl(); // Acoplamento forte
    }

    public void enviarEmail(String email) {
        // Lógica de envio
    }
}
```

**Problemas do código tradicional**:

- Acoplamento forte entre classes
- Difícil de testar
- Difícil de modificar implementações
- Violação do princípio de responsabilidade única

**Com IoC (Spring)**:

```java
@Component
public class ServicoEmail {
    private final RepositorioUsuario repositorio;

    @Autowired
    public ServicoEmail(RepositorioUsuario repositorio) {
        this.repositorio = repositorio; // Injeção de dependência
    }

    public void enviarEmail(String email) {
        // Lógica de envio
    }
}
```

**Vantagens do IoC**:

- Acoplamento frouxo
- Fácil de testar
- Fácil de modificar implementações
- Respeita princípios SOLID

### Injeção de Dependência

O Spring oferece três tipos de injeção de dependência:

#### 1. Injeção por Construtor (Recomendada)

```java
@Service
public class ServicoUsuario {
    private final RepositorioUsuario repositorio;
    private final ServicoEmail servicoEmail;

    @Autowired
    public ServicoUsuario(RepositorioUsuario repositorio,
                         ServicoEmail servicoEmail) {
        this.repositorio = repositorio;
        this.servicoEmail = servicoEmail;
    }

    public void criarUsuario(Usuario usuario) {
        repositorio.salvar(usuario);
        servicoEmail.enviarEmailBoasVindas(usuario.getEmail());
    }
}
```

**Vantagens**:

- Dependências obrigatórias são garantidas
- Imutabilidade (final)
- Fácil de testar
- Melhor performance

#### 2. Injeção por Setter

```java
@Service
public class ServicoUsuario {
    private RepositorioUsuario repositorio;

    @Autowired
    public void setRepositorio(RepositorioUsuario repositorio) {
        this.repositorio = repositorio;
    }

    public void criarUsuario(Usuario usuario) {
        repositorio.salvar(usuario);
    }
}
```

**Use quando**:

- Dependências são opcionais
- Precisa alterar dependências em runtime

#### 3. Injeção por Campo

```java
@Service
public class ServicoUsuario {
    @Autowired
    private RepositorioUsuario repositorio;

    public void criarUsuario(Usuario usuario) {
        repositorio.salvar(usuario);
    }
}
```

**Desvantagens**:

- Difícil de testar
- Dependências não são explícitas
- Não funciona com campos final

### Configuração do Spring

#### 1. Configuração por Anotações (Recomendada)

```java
@Configuration
@ComponentScan("com.exemplo")
@PropertySource("classpath:application.properties")
public class ConfiguracaoApp {

    @Bean
    public RepositorioUsuario repositorioUsuario() {
        return new RepositorioUsuarioImpl();
    }

    @Bean
    public ServicoEmail servicoEmail() {
        return new ServicoEmailImpl();
    }

    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:h2:mem:testdb")
            .username("sa")
            .password("")
            .build();
    }
}
```

#### 2. Configuração por XML (Legado)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.exemplo" />
    <context:property-placeholder location="classpath:application.properties" />

    <bean id="repositorioUsuario"
          class="com.exemplo.RepositorioUsuarioImpl" />

    <bean id="servicoEmail"
          class="com.exemplo.ServicoEmailImpl" />

    <bean id="servicoUsuario"
          class="com.exemplo.ServicoUsuario">
        <constructor-arg ref="repositorioUsuario" />
        <constructor-arg ref="servicoEmail" />
    </bean>

</beans>
```

### Anotações Principais

#### Anotações de Componentes

```java
@Component // Componente genérico
@Service   // Camada de serviço
@Repository // Camada de acesso a dados
@Controller // Controlador web
@Configuration // Classe de configuração
```

#### Anotações de Injeção

```java
@Autowired // Injeção automática
@Qualifier("nomeBean") // Especifica qual bean usar
@Value("${propriedade}") // Injeção de propriedades
@Resource // Injeção por nome
```

#### Anotações de Configuração

```java
@Configuration // Classe de configuração
@Bean // Define um bean
@ComponentScan // Escaneia componentes
@PropertySource // Carrega arquivo de propriedades
@Import // Importa outras configurações
@Profile // Configuração específica por perfil
```

### Exemplo Completo - Sistema de Usuários

#### 1. Modelo de Dados

```java
public class Usuario {
    private Long id;
    private String nome;
    private String email;
    private String senha;
    private LocalDateTime dataCriacao;
    private boolean ativo;

    // Construtores
    public Usuario() {}

    public Usuario(String nome, String email, String senha) {
        this.nome = nome;
        this.email = email;
        this.senha = senha;
        this.dataCriacao = LocalDateTime.now();
        this.ativo = true;
    }

    // Getters e Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public LocalDateTime getDataCriacao() { return dataCriacao; }
    public void setDataCriacao(LocalDateTime dataCriacao) { this.dataCriacao = dataCriacao; }

    public boolean isAtivo() { return ativo; }
    public void setAtivo(boolean ativo) { this.ativo = ativo; }
}
```

#### 2. Interface do Repositório

```java
public interface RepositorioUsuario {
    Usuario buscarPorId(Long id);
    Usuario buscarPorEmail(String email);
    List<Usuario> buscarTodos();
    void salvar(Usuario usuario);
    void atualizar(Usuario usuario);
    void deletar(Long id);
    boolean existePorEmail(String email);
}
```

#### 3. Implementação do Repositório

```java
@Repository
public class RepositorioUsuarioImpl implements RepositorioUsuario {

    private final Map<Long, Usuario> usuarios = new HashMap<>();
    private Long proximoId = 1L;

    @Override
    public Usuario buscarPorId(Long id) {
        return usuarios.get(id);
    }

    @Override
    public Usuario buscarPorEmail(String email) {
        return usuarios.values().stream()
            .filter(u -> u.getEmail().equals(email))
            .findFirst()
            .orElse(null);
    }

    @Override
    public List<Usuario> buscarTodos() {
        return new ArrayList<>(usuarios.values());
    }

    @Override
    public void salvar(Usuario usuario) {
        if (usuario.getId() == null) {
            usuario.setId(proximoId++);
        }
        usuarios.put(usuario.getId(), usuario);
    }

    @Override
    public void atualizar(Usuario usuario) {
        if (usuario.getId() != null && usuarios.containsKey(usuario.getId())) {
            usuarios.put(usuario.getId(), usuario);
        }
    }

    @Override
    public void deletar(Long id) {
        usuarios.remove(id);
    }

    @Override
    public boolean existePorEmail(String email) {
        return usuarios.values().stream()
            .anyMatch(u -> u.getEmail().equals(email));
    }
}
```

#### 4. Serviço de Email

```java
@Service
public class ServicoEmail {

    private final Logger logger = LoggerFactory.getLogger(ServicoEmail.class);

    public void enviarEmailBoasVindas(String email) {
        logger.info("Enviando email de boas-vindas para: {}", email);
        // Implementação real de envio de email
    }

    public void enviarEmailRecuperacaoSenha(String email) {
        logger.info("Enviando email de recuperação de senha para: {}", email);
        // Implementação real de envio de email
    }

    public void enviarEmailConfirmacao(String email) {
        logger.info("Enviando email de confirmação para: {}", email);
        // Implementação real de envio de email
    }
}
```

#### 5. Serviço de Usuário

```java
@Service
@Transactional
public class ServicoUsuario {

    private final RepositorioUsuario repositorio;
    private final ServicoEmail servicoEmail;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public ServicoUsuario(RepositorioUsuario repositorio,
                         ServicoEmail servicoEmail,
                         PasswordEncoder passwordEncoder) {
        this.repositorio = repositorio;
        this.servicoEmail = servicoEmail;
        this.passwordEncoder = passwordEncoder;
    }

    public Usuario criarUsuario(Usuario usuario) {
        // Validações
        if (usuario.getNome() == null || usuario.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Nome é obrigatório");
        }

        if (usuario.getEmail() == null || usuario.getEmail().trim().isEmpty()) {
            throw new IllegalArgumentException("Email é obrigatório");
        }

        if (repositorio.existePorEmail(usuario.getEmail())) {
            throw new IllegalArgumentException("Email já cadastrado");
        }

        // Criptografar senha
        if (usuario.getSenha() != null) {
            usuario.setSenha(passwordEncoder.encode(usuario.getSenha()));
        }

        // Salvar usuário
        repositorio.salvar(usuario);

        // Enviar email de boas-vindas
        servicoEmail.enviarEmailBoasVindas(usuario.getEmail());

        return usuario;
    }

    public Usuario buscarPorId(Long id) {
        Usuario usuario = repositorio.buscarPorId(id);
        if (usuario == null) {
            throw new IllegalArgumentException("Usuário não encontrado");
        }
        return usuario;
    }

    public List<Usuario> buscarTodos() {
        return repositorio.buscarTodos();
    }

    public Usuario atualizarUsuario(Long id, Usuario usuarioAtualizado) {
        Usuario usuarioExistente = buscarPorId(id);

        if (usuarioAtualizado.getNome() != null) {
            usuarioExistente.setNome(usuarioAtualizado.getNome());
        }

        if (usuarioAtualizado.getEmail() != null) {
            // Verificar se email já existe em outro usuário
            Usuario usuarioComEmail = repositorio.buscarPorEmail(usuarioAtualizado.getEmail());
            if (usuarioComEmail != null && !usuarioComEmail.getId().equals(id)) {
                throw new IllegalArgumentException("Email já cadastrado");
            }
            usuarioExistente.setEmail(usuarioAtualizado.getEmail());
        }

        if (usuarioAtualizado.getSenha() != null) {
            usuarioExistente.setSenha(passwordEncoder.encode(usuarioAtualizado.getSenha()));
        }

        repositorio.atualizar(usuarioExistente);
        return usuarioExistente;
    }

    public void deletarUsuario(Long id) {
        Usuario usuario = buscarPorId(id);
        repositorio.deletar(id);
    }

    public void ativarUsuario(Long id) {
        Usuario usuario = buscarPorId(id);
        usuario.setAtivo(true);
        repositorio.atualizar(usuario);
    }

    public void desativarUsuario(Long id) {
        Usuario usuario = buscarPorId(id);
        usuario.setAtivo(false);
        repositorio.atualizar(usuario);
    }
}
```

#### 6. Controlador REST

```java
@RestController
@RequestMapping("/api/usuarios")
public class UsuarioController {

    private final ServicoUsuario servicoUsuario;

    @Autowired
    public UsuarioController(ServicoUsuario servicoUsuario) {
        this.servicoUsuario = servicoUsuario;
    }

    @PostMapping
    public ResponseEntity<Usuario> criarUsuario(@RequestBody @Valid Usuario usuario) {
        try {
            Usuario usuarioCriado = servicoUsuario.criarUsuario(usuario);
            return ResponseEntity.status(HttpStatus.CREATED).body(usuarioCriado);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<Usuario> buscarUsuario(@PathVariable Long id) {
        try {
            Usuario usuario = servicoUsuario.buscarPorId(id);
            return ResponseEntity.ok(usuario);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping
    public ResponseEntity<List<Usuario>> buscarTodos() {
        List<Usuario> usuarios = servicoUsuario.buscarTodos();
        return ResponseEntity.ok(usuarios);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Usuario> atualizarUsuario(@PathVariable Long id,
                                                   @RequestBody @Valid Usuario usuario) {
        try {
            Usuario usuarioAtualizado = servicoUsuario.atualizarUsuario(id, usuario);
            return ResponseEntity.ok(usuarioAtualizado);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarUsuario(@PathVariable Long id) {
        try {
            servicoUsuario.deletarUsuario(id);
            return ResponseEntity.noContent().build();
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @PatchMapping("/{id}/ativar")
    public ResponseEntity<Void> ativarUsuario(@PathVariable Long id) {
        try {
            servicoUsuario.ativarUsuario(id);
            return ResponseEntity.ok().build();
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @PatchMapping("/{id}/desativar")
    public ResponseEntity<Void> desativarUsuario(@PathVariable Long id) {
        try {
            servicoUsuario.desativarUsuario(id);
            return ResponseEntity.ok().build();
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }
}
```

### Gerenciamento de Transações

```java
@Service
@Transactional
public class ServicoTransacao {

    private final RepositorioConta repositorioConta;
    private final RepositorioTransacao repositorioTransacao;

    @Autowired
    public ServicoTransacao(RepositorioConta repositorioConta,
                           RepositorioTransacao repositorioTransacao) {
        this.repositorioConta = repositorioConta;
        this.repositorioTransacao = repositorioTransacao;
    }

    @Transactional
    public void transferir(Long contaOrigem, Long contaDestino, BigDecimal valor) {
        // Buscar contas
        Conta origem = repositorioConta.buscarPorId(contaOrigem);
        Conta destino = repositorioConta.buscarPorId(contaDestino);

        if (origem == null || destino == null) {
            throw new IllegalArgumentException("Conta não encontrada");
        }

        if (origem.getSaldo().compareTo(valor) < 0) {
            throw new IllegalArgumentException("Saldo insuficiente");
        }

        // Debitar da conta origem
        origem.setSaldo(origem.getSaldo().subtract(valor));
        repositorioConta.atualizar(origem);

        // Creditar na conta destino
        destino.setSaldo(destino.getSaldo().add(valor));
        repositorioConta.atualizar(destino);

        // Registrar transação
        Transacao transacao = new Transacao(origem.getId(), destino.getId(), valor);
        repositorioTransacao.salvar(transacao);
    }

    @Transactional(readOnly = true)
    public BigDecimal consultarSaldo(Long contaId) {
        Conta conta = repositorioConta.buscarPorId(contaId);
        if (conta == null) {
            throw new IllegalArgumentException("Conta não encontrada");
        }
        return conta.getSaldo();
    }

    @Transactional(readOnly = true)
    public List<Transacao> buscarTransacoes(Long contaId) {
        return repositorioTransacao.buscarPorConta(contaId);
    }
}
```

### AOP (Aspect-Oriented Programming)

```java
@Aspect
@Component
public class LoggingAspect {

    private final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Before("execution(* com.exemplo.*.ServicoUsuario.*(..))")
    public void logAntesDoMetodo(JoinPoint joinPoint) {
        String metodo = joinPoint.getSignature().getName();
        String classe = joinPoint.getTarget().getClass().getSimpleName();
        logger.info("Executando método: {}.{}", classe, metodo);
    }

    @AfterReturning(pointcut = "execution(* com.exemplo.*.ServicoUsuario.*(..))",
                    returning = "resultado")
    public void logAposSucesso(JoinPoint joinPoint, Object resultado) {
        String metodo = joinPoint.getSignature().getName();
        logger.info("Método {} executado com sucesso", metodo);
    }

    @AfterThrowing(pointcut = "execution(* com.exemplo.*.*(..))",
                   throwing = "erro")
    public void logErro(JoinPoint joinPoint, Throwable erro) {
        String metodo = joinPoint.getSignature().getName();
        String classe = joinPoint.getTarget().getClass().getSimpleName();
        logger.error("Erro no método {}.{}: {}", classe, metodo, erro.getMessage());
    }

    @Around("execution(* com.exemplo.*.ServicoUsuario.*(..))")
    public Object medirTempoExecucao(ProceedingJoinPoint joinPoint) throws Throwable {
        long inicio = System.currentTimeMillis();

        try {
            Object resultado = joinPoint.proceed();
            long tempo = System.currentTimeMillis() - inicio;
            logger.info("Método {} executado em {}ms",
                       joinPoint.getSignature().getName(), tempo);
            return resultado;
        } catch (Throwable e) {
            long tempo = System.currentTimeMillis() - inicio;
            logger.error("Método {} falhou após {}ms",
                        joinPoint.getSignature().getName(), tempo);
            throw e;
        }
    }
}
```

### Testes com Spring

```java
@SpringBootTest
class ServicoUsuarioTest {

    @Autowired
    private ServicoUsuario servicoUsuario;

    @MockBean
    private RepositorioUsuario repositorioUsuario;

    @MockBean
    private ServicoEmail servicoEmail;

    @MockBean
    private PasswordEncoder passwordEncoder;

    @Test
    void deveCriarUsuarioComSucesso() {
        // Given
        Usuario usuario = new Usuario("João", "joao@email.com", "senha123");
        Usuario usuarioSalvo = new Usuario("João", "joao@email.com", "senha123");
        usuarioSalvo.setId(1L);

        when(repositorioUsuario.existePorEmail("joao@email.com")).thenReturn(false);
        when(passwordEncoder.encode("senha123")).thenReturn("senhaCriptografada");
        when(repositorioUsuario.salvar(any(Usuario.class))).thenAnswer(invocation -> {
            Usuario u = invocation.getArgument(0);
            u.setId(1L);
            return u;
        });

        // When
        Usuario resultado = servicoUsuario.criarUsuario(usuario);

        // Then
        assertThat(resultado.getId()).isEqualTo(1L);
        assertThat(resultado.getNome()).isEqualTo("João");
        assertThat(resultado.getEmail()).isEqualTo("joao@email.com");
        assertThat(resultado.getSenha()).isEqualTo("senhaCriptografada");
        assertThat(resultado.isAtivo()).isTrue();

        verify(repositorioUsuario).existePorEmail("joao@email.com");
        verify(passwordEncoder).encode("senha123");
        verify(repositorioUsuario).salvar(any(Usuario.class));
        verify(servicoEmail).enviarEmailBoasVindas("joao@email.com");
    }

    @Test
    void deveFalharQuandoEmailJaExiste() {
        // Given
        Usuario usuario = new Usuario("João", "joao@email.com", "senha123");
        when(repositorioUsuario.existePorEmail("joao@email.com")).thenReturn(true);

        // When & Then
        assertThatThrownBy(() -> servicoUsuario.criarUsuario(usuario))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("Email já cadastrado");

        verify(repositorioUsuario).existePorEmail("joao@email.com");
        verify(repositorioUsuario, never()).salvar(any());
        verify(servicoEmail, never()).enviarEmailBoasVindas(any());
    }

    @Test
    void deveFalharQuandoNomeEstaVazio() {
        // Given
        Usuario usuario = new Usuario("", "joao@email.com", "senha123");

        // When & Then
        assertThatThrownBy(() -> servicoUsuario.criarUsuario(usuario))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("Nome é obrigatório");
    }

    @Test
    void deveFalharQuandoEmailEstaVazio() {
        // Given
        Usuario usuario = new Usuario("João", "", "senha123");

        // When & Then
        assertThatThrownBy(() -> servicoUsuario.criarUsuario(usuario))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("Email é obrigatório");
    }
}
```

### Configuração de Propriedades

```properties
# Database Configuration
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA Configuration
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Logging Configuration
logging.level.com.exemplo=DEBUG
logging.level.org.springframework.security=DEBUG

# Server Configuration
server.port=8080
server.servlet.context-path=/api

# Security Configuration
spring.security.user.name=admin
spring.security.user.password=admin
```

### Vantagens do Spring

1. **Produtividade**: Menos código boilerplate
2. **Testabilidade**: Fácil de testar com injeção de dependência
3. **Flexibilidade**: Módulos independentes
4. **Ecosistema**: Grande comunidade e bibliotecas
5. **Padrões**: Implementa padrões de projeto comprovados
6. **Manutenibilidade**: Código limpo e organizado
7. **Escalabilidade**: Suporte a aplicações enterprise
8. **Performance**: Otimizações automáticas

### Conclusão

O Spring Framework revolucionou o desenvolvimento Java enterprise. Sua arquitetura baseada em IoC e DI torna o código mais limpo, testável e manutenível. Com sua vasta gama de módulos e anotações, o Spring simplifica o desenvolvimento de aplicações complexas.

---

## Exercícios

### Nível Básico

#### Exercício 1: Configuração Básica

Crie uma aplicação Spring simples que tenha:

- Uma classe `Produto` com id, nome, preço e categoria
- Um repositório para gerenciar produtos
- Um serviço que implementa lógica de negócio
- Um controlador REST para operações CRUD

**Resolução**:

```java
// Modelo
public class Produto {
    private Long id;
    private String nome;
    private BigDecimal preco;
    private String categoria;

    // Construtores, getters, setters...
}

// Repositório
@Repository
public class RepositorioProdutoImpl implements RepositorioProduto {
    private final Map<Long, Produto> produtos = new HashMap<>();
    private Long proximoId = 1L;

    @Override
    public Produto buscarPorId(Long id) {
        return produtos.get(id);
    }

    @Override
    public List<Produto> buscarTodos() {
        return new ArrayList<>(produtos.values());
    }

    @Override
    public void salvar(Produto produto) {
        if (produto.getId() == null) {
            produto.setId(proximoId++);
        }
        produtos.put(produto.getId(), produto);
    }

    @Override
    public void deletar(Long id) {
        produtos.remove(id);
    }
}

// Serviço
@Service
public class ServicoProduto {
    private final RepositorioProduto repositorio;

    @Autowired
    public ServicoProduto(RepositorioProduto repositorio) {
        this.repositorio = repositorio;
    }

    public Produto criarProduto(Produto produto) {
        if (produto.getNome() == null || produto.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Nome é obrigatório");
        }
        if (produto.getPreco() == null || produto.getPreco().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Preço deve ser maior que zero");
        }

        repositorio.salvar(produto);
        return produto;
    }

    public Produto buscarPorId(Long id) {
        Produto produto = repositorio.buscarPorId(id);
        if (produto == null) {
            throw new IllegalArgumentException("Produto não encontrado");
        }
        return produto;
    }

    public List<Produto> buscarTodos() {
        return repositorio.buscarTodos();
    }

    public void deletarProduto(Long id) {
        buscarPorId(id); // Valida se existe
        repositorio.deletar(id);
    }
}

// Controlador
@RestController
@RequestMapping("/api/produtos")
public class ProdutoController {
    private final ServicoProduto servicoProduto;

    @Autowired
    public ProdutoController(ServicoProduto servicoProduto) {
        this.servicoProduto = servicoProduto;
    }

    @PostMapping
    public ResponseEntity<Produto> criarProduto(@RequestBody Produto produto) {
        try {
            Produto produtoCriado = servicoProduto.criarProduto(produto);
            return ResponseEntity.status(HttpStatus.CREATED).body(produtoCriado);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<Produto> buscarProduto(@PathVariable Long id) {
        try {
            Produto produto = servicoProduto.buscarPorId(id);
            return ResponseEntity.ok(produto);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping
    public ResponseEntity<List<Produto>> buscarTodos() {
        List<Produto> produtos = servicoProduto.buscarTodos();
        return ResponseEntity.ok(produtos);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarProduto(@PathVariable Long id) {
        try {
            servicoProduto.deletarProduto(id);
            return ResponseEntity.noContent().build();
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }
}
```

#### Exercício 2: Injeção de Dependência

Crie um sistema de notificações com diferentes tipos de notificação (email, SMS, push). Use injeção de dependência para escolher o tipo de notificação.

**Resolução**:

```java
// Interface de notificação
public interface NotificacaoService {
    void enviarNotificacao(String destinatario, String mensagem);
}

// Implementações
@Service
public class EmailNotificacaoService implements NotificacaoService {
    @Override
    public void enviarNotificacao(String destinatario, String mensagem) {
        System.out.println("Enviando email para " + destinatario + ": " + mensagem);
    }
}

@Service
public class SmsNotificacaoService implements NotificacaoService {
    @Override
    public void enviarNotificacao(String destinatario, String mensagem) {
        System.out.println("Enviando SMS para " + destinatario + ": " + mensagem);
    }
}

@Service
public class PushNotificacaoService implements NotificacaoService {
    @Override
    public void enviarNotificacao(String destinatario, String mensagem) {
        System.out.println("Enviando push para " + destinatario + ": " + mensagem);
    }
}

// Serviço principal
@Service
public class ServicoNotificacao {
    private final NotificacaoService emailService;
    private final NotificacaoService smsService;
    private final NotificacaoService pushService;

    @Autowired
    public ServicoNotificacao(@Qualifier("emailNotificacaoService") NotificacaoService emailService,
                             @Qualifier("smsNotificacaoService") NotificacaoService smsService,
                             @Qualifier("pushNotificacaoService") NotificacaoService pushService) {
        this.emailService = emailService;
        this.smsService = smsService;
        this.pushService = pushService;
    }

    public void enviarNotificacao(String destinatario, String mensagem, String tipo) {
        switch (tipo.toLowerCase()) {
            case "email":
                emailService.enviarNotificacao(destinatario, mensagem);
                break;
            case "sms":
                smsService.enviarNotificacao(destinatario, mensagem);
                break;
            case "push":
                pushService.enviarNotificacao(destinatario, mensagem);
                break;
            default:
                throw new IllegalArgumentException("Tipo de notificação inválido");
        }
    }
}
```

### Nível Intermediário

#### Exercício 3: Transações

Implemente um sistema de transferência bancária com controle de transações. A transferência deve ser atômica (ou tudo ou nada).

**Resolução**:

```java
@Entity
public class Conta {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String numero;
    private BigDecimal saldo;
    private String titular;

    // Construtores, getters, setters...
}

@Repository
public interface RepositorioConta extends JpaRepository<Conta, Long> {
    Optional<Conta> findByNumero(String numero);
}

@Service
@Transactional
public class ServicoTransferencia {
    private final RepositorioConta repositorioConta;

    @Autowired
    public ServicoTransferencia(RepositorioConta repositorioConta) {
        this.repositorioConta = repositorioConta;
    }

    @Transactional
    public void transferir(String contaOrigem, String contaDestino, BigDecimal valor) {
        Conta origem = repositorioConta.findByNumero(contaOrigem)
            .orElseThrow(() -> new IllegalArgumentException("Conta origem não encontrada"));

        Conta destino = repositorioConta.findByNumero(contaDestino)
            .orElseThrow(() -> new IllegalArgumentException("Conta destino não encontrada"));

        if (origem.getSaldo().compareTo(valor) < 0) {
            throw new IllegalArgumentException("Saldo insuficiente");
        }

        if (valor.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Valor deve ser maior que zero");
        }

        // Debitar da conta origem
        origem.setSaldo(origem.getSaldo().subtract(valor));
        repositorioConta.save(origem);

        // Creditar na conta destino
        destino.setSaldo(destino.getSaldo().add(valor));
        repositorioConta.save(destino);
    }

    @Transactional(readOnly = true)
    public BigDecimal consultarSaldo(String numeroConta) {
        Conta conta = repositorioConta.findByNumero(numeroConta)
            .orElseThrow(() -> new IllegalArgumentException("Conta não encontrada"));
        return conta.getSaldo();
    }
}
```

#### Exercício 4: AOP

Crie um aspecto que registre o tempo de execução de todos os métodos de serviço e logue erros.

**Resolução**:

```java
@Aspect
@Component
public class LoggingAspect {
    private final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Around("execution(* com.exemplo.*.Servico.*(..))")
    public Object medirTempoExecucao(ProceedingJoinPoint joinPoint) throws Throwable {
        long inicio = System.currentTimeMillis();
        String metodo = joinPoint.getSignature().getName();
        String classe = joinPoint.getTarget().getClass().getSimpleName();

        try {
            Object resultado = joinPoint.proceed();
            long tempo = System.currentTimeMillis() - inicio;
            logger.info("Método {}.{} executado em {}ms", classe, metodo, tempo);
            return resultado;
        } catch (Throwable e) {
            long tempo = System.currentTimeMillis() - inicio;
            logger.error("Método {}.{} falhou após {}ms com erro: {}",
                        classe, metodo, tempo, e.getMessage());
            throw e;
        }
    }

    @AfterThrowing(pointcut = "execution(* com.exemplo.*.*(..))", throwing = "erro")
    public void logErro(JoinPoint joinPoint, Throwable erro) {
        String metodo = joinPoint.getSignature().getName();
        String classe = joinPoint.getTarget().getClass().getSimpleName();
        logger.error("Erro no método {}.{}: {}", classe, metodo, erro.getMessage());
    }
}
```

### Nível Avançado

#### Exercício 5: Configuração Condicional

Crie uma aplicação que use diferentes configurações baseadas no perfil (dev, prod, test).

**Resolução**:

```java
@Configuration
@Profile("dev")
public class ConfiguracaoDev {

    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:h2:mem:devdb")
            .username("sa")
            .password("")
            .build();
    }

    @Bean
    public NotificacaoService notificacaoService() {
        return new EmailNotificacaoService();
    }
}

@Configuration
@Profile("prod")
public class ConfiguracaoProd {

    @Bean
    @ConfigurationProperties("spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public NotificacaoService notificacaoService() {
        return new SmsNotificacaoService();
    }
}

@Configuration
@Profile("test")
public class ConfiguracaoTest {

    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:h2:mem:testdb")
            .username("sa")
            .password("")
            .build();
    }

    @Bean
    public NotificacaoService notificacaoService() {
        return new MockNotificacaoService();
    }
}
```

#### Exercício 6: Eventos Customizados

Implemente um sistema de eventos para notificar quando um usuário é criado ou atualizado.

**Resolução**:

```java
// Eventos
public class UsuarioCriadoEvent extends ApplicationEvent {
    private final Usuario usuario;

    public UsuarioCriadoEvent(Object source, Usuario usuario) {
        super(source);
        this.usuario = usuario;
    }

    public Usuario getUsuario() {
        return usuario;
    }
}

public class UsuarioAtualizadoEvent extends ApplicationEvent {
    private final Usuario usuario;

    public UsuarioAtualizadoEvent(Object source, Usuario usuario) {
        super(source);
        this.usuario = usuario;
    }

    public Usuario getUsuario() {
        return usuario;
    }
}

// Listeners
@Component
public class UsuarioEventListener {
    private final Logger logger = LoggerFactory.getLogger(UsuarioEventListener.class);
    private final ServicoEmail servicoEmail;

    @Autowired
    public UsuarioEventListener(ServicoEmail servicoEmail) {
        this.servicoEmail = servicoEmail;
    }

    @EventListener
    public void handleUsuarioCriado(UsuarioCriadoEvent event) {
        Usuario usuario = event.getUsuario();
        logger.info("Usuário criado: {}", usuario.getEmail());
        servicoEmail.enviarEmailBoasVindas(usuario.getEmail());
    }

    @EventListener
    public void handleUsuarioAtualizado(UsuarioAtualizadoEvent event) {
        Usuario usuario = event.getUsuario();
        logger.info("Usuário atualizado: {}", usuario.getEmail());
        servicoEmail.enviarEmailConfirmacao(usuario.getEmail());
    }
}

// Serviço atualizado
@Service
public class ServicoUsuario {
    private final RepositorioUsuario repositorio;
    private final ApplicationEventPublisher eventPublisher;

    @Autowired
    public ServicoUsuario(RepositorioUsuario repositorio,
                         ApplicationEventPublisher eventPublisher) {
        this.repositorio = repositorio;
        this.eventPublisher = eventPublisher;
    }

    public Usuario criarUsuario(Usuario usuario) {
        // Validações...
        repositorio.salvar(usuario);

        // Publicar evento
        eventPublisher.publishEvent(new UsuarioCriadoEvent(this, usuario));

        return usuario;
    }

    public Usuario atualizarUsuario(Long id, Usuario usuarioAtualizado) {
        // Lógica de atualização...
        repositorio.atualizar(usuarioAtualizado);

        // Publicar evento
        eventPublisher.publishEvent(new UsuarioAtualizadoEvent(this, usuarioAtualizado));

        return usuarioAtualizado;
    }
}
```
